<div class="step-text">
<p>With <code class="language-python">*args</code> you can create more flexible functions that accept a varying number of <em>positional</em> arguments. You may now wonder how to do the same with <em>named</em> arguments. Fortunately, in Python, you can work with <em>keyword</em> arguments in a similar way.</p>
<h5 id="multiple-keyword-arguments" style="text-align: center;">Multiple keyword arguments</h5>
<p>Let's get acquainted with the <code class="language-python">**</code> operator used to pass a varying number of <a class="theory-lookup not-relevant" href="/learn/step/9544" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a keyword argument is a way to pass an argument to a function by specifying the parameter name along with the value. | This allows for more flexibility in assigning arguments, as the order of the arguments does not matter when using keyword arguments. Keyword arguments can be used in conjunction with positional arguments, and can make the code easier to read and follow, reducing the chance of errors and bugs. When defining a function, you can specify default values for keyword arguments, which allows the function to be called with fewer arguments than it is defined to accept.">keyword arguments</a> into a function. <code class="language-python">**kwargs</code> collects all possible extra values in a dictionary with keywords as keys.</p>
<p>By convention, people use special names for this kind of arguments: <code class="language-python">*args</code> for positional arguments and <code class="language-python">**kwargs</code> for keyword arguments, but you can call them whatever you want. The main thing is that a single asterisk <code class="language-python">*</code> matches a value by position and a double asterisk <code class="language-python">**</code> associates a value with a name, or keyword. So, <code class="language-python">**kwargs</code> differs from <code class="language-python">*args</code> in that you will need to assign keywords.</p>
<p>Here is an example:</p>
<pre><code class="language-python">def capital(**kwargs):
    for key, value in kwargs.items():
        print(value, "is the capital city of", key)


capital(Canada="Ottawa", Estonia="Tallinn", Venezuela="Caracas", Finland="Helsinki")</code></pre>
<p>Once the function has been invoked, these 4 lines will be printed:</p>
<pre><code class="language-no-highlight">Ottawa is the capital city of Canada
Tallinn is the capital city of Estonia
Caracas is the capital city of Venezuela
Helsinki is the capital city of Finland</code></pre>
<p>So, everything works just fine! And again, the number of arguments we pass may differ in the next call.</p>
<p></p>
<div class="alert alert-primary">Note that the names in a call are without quotes. That is not a mistake. Moreover, the names should be valid, for example, you cannot start a keyword with a number. Follow the same naming rules as for variables.</div>
<p></p>
<p>It is also possible to combine <code class="language-python">*args</code> and <code class="language-python">**kwargs</code> in one function definition:</p>
<pre><code class="language-python">def func(positional_args, defaults, *args, **kwargs):
    pass</code></pre>
<p>The order is crucial here. Just as non-keyword arguments precede keyword arguments, <code class="language-python">*args</code> must come before <code class="language-python">**kwargs</code> in this case. Otherwise, both when creating and calling a function with <code class="language-python">*args</code> and <code class="language-python">**kwargs</code> in the wrong order, a <code class="language-python">SyntaxError</code> will appear:</p>
<pre><code class="language-python">def func(positional_args, defaults, **kwargs, *args):
# SyntaxError: invalid syntax

func(positional_args, defaults, **kwargs, *args)
# SyntaxError: iterable argument unpacking follows keyword argument unpacking</code></pre>
<h5 id="unpacking-in-function-calls" style="text-align: center;">Unpacking in function calls</h5>
<p>There are two <a class="theory-lookup not-relevant" href="/learn/step/9544" rel="noopener noreferrer nofollow" target="_blank" title="In Python, unpacking operator is a syntax that allows us to extract values from collections such as lists, sets, tuples, strings, dictionaries, or any iterable object. | The unpacking operator is represented by the asterisk symbol (*). There are two types of unpacking: single asterisk (*) and double-asterisk (**) operators. The single asterisk operator is used to unpack a single iterable, while the double-asterisk operator is used to unpack keyword arguments in a function call. Unpacking is useful when working with different data structures, as it allows us to iterate over them in parallel, making our code more readable and concise.">unpacking operators</a> in Python: a single asterisk <code class="language-python">*</code> unpacks elements of an iterable object and a double asterisk <code class="language-python">**</code> works with dictionaries. Let's try to get key-value pairs from a dictionary and pass them as keyword arguments using a double asterisk <code class="language-python">**</code>:</p>
<pre><code class="language-python">def say_bye(**names):
    for name in names:
        print("Au revoir,", name)
        print("See you on", names[name]["next appointment"])
        print()


humans = {"Laura": {"next appointment": "Tuesday"},
          "Robin": {"next appointment": "Friday"}}

say_bye(**humans)

# Au revoir, Laura
# See you on Tuesday
# 
# Au revoir, Robin
# See you on Friday</code></pre>
<p>By default, you iterate over keys in a dictionary, so be careful with this. You might need this type of unpacking when setting specific parameters of a function. Saving values in a dictionary and then unpacking them in this way might be much easier than listing them in each call manually. Also, it will save time when you choose to fine-tune these parameters.</p>
<h5 id="summary" style="text-align: center;">Summary</h5>
<p>Let's go over the main points discussed in the topic:</p>
<ul>
<li>If you want to work with a varying number of <strong>keyword </strong>arguments, make use of <code class="language-python">**kwargs</code>.</li>
<li>The variable name <code class="language-python">kwargs</code> is conventional, you can always choose another one.</li>
<li>Notice the difference: <code class="language-python">*args</code> provides access to a <strong>tuple </strong>of remaining values, while <code class="language-python">**kwargs</code> collects remaining key-value pairs in a <strong>dictionary</strong>.</li>
<li>The order of parameters in the function definition is important, as well as the order of passed arguments.</li>
<li>In function calls, now you can use both <strong>unpacking operators:</strong> a single asterisk <code class="language-python">*</code> for iterable objects and a double asterisk <code class="language-python">**</code> for dictionaries.</li>
</ul>
</div>